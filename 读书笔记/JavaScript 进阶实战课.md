# JavaScript 进阶实战

## 开篇词

### 概念

1. 在函数式编程中，我们通常会把各种干扰，就叫做**副作用**（Side effect）。

   函数已经把算法封装了起来，那么函数里相对就是可控的，而比较不可控的是外部环境。外部环境常见的副作用有三类：1.全局变量；2.io 影响（浏览器或者 node 服务器等）；3.网络请求。

   函数式编程最核心的地方，就是输入输出和中间的算法，我们要解决的核心问题就是副作用。而为了解决副作用，我们需要掌握两个重要的概念，一个是纯函数，一个是不可变。纯函数强调的是自身的稳定性，对结果只影响一次；而不可变强调的是和外界的交互中，尽量减少相互间负面的影响。

2. 减少副作用的方法：纯函数、不可变。这是一个“双循环”，纯函数更多解决的是“内循环”；而不可变更多考虑的是“外循环”。纯函数就可以通过减少对外界不确定因素的依赖，来减少副作用。
3. **纯函数**：一个函数的返回结果的变化只依赖其参数，并且执行过程中没有副作用。也就是只要参数不变，返回结果也不变。相关的例子，函数中的计算的变量，除了传入的形参以外还依赖函数外部的一些变量，这种就不是纯函数，因为不能保证所依赖的函数外部的变量值始终不变。
4. **不可变**就是在减少程序被外界影响的同时，也减少对外界的影响。因为如果你把一个外部变量作为参数作为输入，在函数里做了改变，作为输出返回。那么这个过程中，你可能不知道这种变化会对整个系统造成什么样的结果。比如数组中的 splice(切割，会改变原数组)和 slice(截取，不会改变原数组)

   > 数组中有很多的纯函数、非纯函数，以及可变与不可变的例子。纯函数方法有：slice - concat，map - filter，reduce - reduceRight。非纯函数方法有：fill - splice，pop - push，shift - unshift，sort - reverse

5. 函数本身作为对象，也可以是输入或输出值，我们把这种函数就叫做**高阶函数**（HOF: higher order functions）。

### 技巧

1. 使用纯函数思想中的幂等，来保证任意多次执行结果与一次执行结果相同，避免订单的重复提交。
2. 通过函数式 + 响应式编程，我们就可以通过用户的实时需求动态加载资源，从而能够节省不必要的资源预加载成本。
3. 在面对混乱时，应该按这三步走：行动、感知、响应。
4. JavaScript 中的继承，是基于原型链的继承，更偏向 delegation(委托) 而不是 inheritance(继承)。即使在面向对象设计本身，也是追求多用组合少用继承。

## 02 如何通过闭包对象管理程序中状态的变化

1. 单纯从值的状态管理和围绕它的一系列行为的角度来看，闭包和对象可以起到异曲同工的作用。比如上面闭包例子中的状态，就是对象中的属性，我们在闭包中创建的针对值的行为，也可以在对象中通过方法来实现。但是它们在隐私（privacy）、状态拷贝（state cloning）和性能（performance）上。还是有差别的，而这些差别在结构性地处理值的问题上，具有不同的优劣势。

   闭包的属性上默认是隐藏，可通过接口读取，也可以通过接口细粒度控制更改我们想要暴露或隐藏的属性及相关的操作；状态拷贝相对难考贝；性能相对低。

   而对象的属性默认是可见的，值也容易更改，如果想要遵循不可变的原则，可通过 Object.freeze() 方法把所有的对象设置成只读（该操作不可逆），保证整体不可变；状态拷贝相对容易；性能方面也相对高一些。

2. 我们通常需要通过诸如数组、对象类的数据结构，来保存“一系列”状态，那么在面对这一类的数据时，我们如何做到遵循不可变的原则呢？---- 要解决这个问题，我们可以通过拷贝 + 更新的方式。也就是说，我们不对原始的对象和数组值做改变，而是拷贝之后，在拷贝的版本上做变更。
3. 通过对状态的拷贝，是可以做到不可变，不过随之而来的就是性能问题。实际上，在这种情况下，有一个解决方案就是用到一个类似**链表**的结构，当中有一组对象记录改变的指数和相关的值。其实目前在市面上，已经有很多成熟的三方库比如 immutable.js，它们会有自己的数据结构，比如 array list 和 object map，以及相关算法来解决类似的问题了。
4. 对象或数组的浅拷贝，是简单的值的复制，这对于对象属性值或数组元素是简单类型来说没有问题；如果对象属性值或数组元素是复杂类型，存的是一个内存地址，对内存地址的复制，只是多了一个指向同一个空间的指针。这时需要进行深拷贝，常用的方式通过递归的方式。深拷贝的简单实现是 JSON.parse(JSON.stringify(obj))，不过考虑到 JSON safe 和性能问题，递归是会更好一些。React 中的 setState()是浅合并而不是深拷贝，会不会影响看情况，如果是“复杂类型”也就是嵌套对象，那就会被影响了。
5. `[...array] {...obj}`展开运算符是浅拷贝。
6. React.memo 和 React.PureComponent 是一个浅对比。如果想对比更复杂的对象，React.memo 也支持在第二个实参传入自定义的对比功能。虽然 React.PureComponent 中的 shouldComponentUpdate() 基于性能考虑，不建议用深对比和 JSON.stringify()；但如果程序中确实是需要处理复杂的数据结构变化的话，可以用 force update 或 immutable-js 来满足类似的需求。
7. 在 React.js 中，它选择使用对象作为 props 和 state 的值类型，能更容易保证属性和状态值的整体不可变；而且面对状态的变化，它也更容易拷贝；在处理高频交互时，它的性能也会更好。而闭包虽然有隐私上的优势和更细粒度的操作，可是在应用交互和状态管理这个场景下，它并没有什么实际的作用。所以，有利于使用对象的条件会相对多一些。

## 03 如何通过部分应用和柯里化让函数具象化？

柯里化和部分应用最大的应用场景就是当一次只传入一个或部分参数的时候。

```js
// 部分应用
var parity =
  (fn, ...preArgs) =>
  (...laterArgs) =>
    fn(...preArgs, ...laterArgs);
```

```js
// 柯里化
function curry(fn, arity = fn.length) {
  return (function nextCurried(prevArgs) {
    return function curried(nextArg) {
      var args = [...prevArgs, nextArg];
      if (args.length >= arity) {
        return fn(...args);
      } else {
        return nextCurried(args);
      }
    };
  })([]);
}
```

## 04 如何通过组合、管道和 reducer 让函数抽象化？

1. 独立的组合函数

   ```js
   function compose(...fns) {
     return fns.reverse().reduce(function reducer(fn1, fn2) {
       return function composed(...args) {
         return fn2(fn1(...args));
       };
     });
   }
   ```

2. JavaScript 中的管道

   ```js
   function reverseArgs(fn) {
     return function argsReversed(...args) {
       return fn(...args.reverse());
     };
   }
   var pipe = reverseArgs(compose);
   ```

3. 组合和管道以及部分应用和柯里化正好相反，一个是从具象走向抽象，一个是从抽象走向具象。不过，虽然说它们的方向是相反的，但有一条原则是一致的，那就是**每个函数尽量有一个单一职责，只专注做好一件事**。

## 05 map、reduce 和 monad 如何围绕值进行操作？

1. **函子**（functor）其实就是一个值和围绕值的一些功能。array.map 可以被看做是一个 functor，它有一组值，而如 map 这样的方法可以作用于数组里面的每一个值，提供了一个映射的功能。
2. 而**单子**（monad）就是在 functor 的基础上，又增加了一些特殊功能，其中最常见的就是 chain 和应用函子（applicative)。
3.
