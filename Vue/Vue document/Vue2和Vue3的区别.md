# Vue2 和 Vue3 的区别

## 底层实现上有什么区别？

1. **虚拟 DOM 重写**：Vue3 对虚拟 DOM 的实现进行了重写，采用了新的算法（Fragment+Block）和数据结构，提高了渲染性能和内存利用率。新的虚拟 DOM 实现更加高效，减少了创建和比较虚拟 DOM 的开销。
2. **Composition API**：Vue3 引入了 Composition API，提供了一种新的组件组织方式。Composition API 通过函数式的 API 风格，将组件的逻辑按照功能划分为模块化的代码块，增强了代码的可读性、可维护性和重用性。
3. **响应式系统改进**：Vue3 对响应式系统进行了优化和改进。新的响应式系统使用了 Proxy 代理，提供了更好的性能和更细粒度的响应式追踪。它解决了 Vue2 中响应式系统的一些限制，例如无法响应新增或删除的属性、数组元素的索引追踪等问题。
4. **更小的体积**：Vue3 在底层实现上进行了一些优化和精简，使得整体体积更小，提高了加载和执行性能。
5. **编译优化**：Vue3 对编译器进行了改进，引入了静态模板提升（Static Template Inlining）和更好的代码生成策略，提高了模板编译的效率和运行时的性能。
6. **TypeScript 支持**：Vue3 更加深入地整合了 TypeScript，并使用 TypeScript 进行开发，提供了更好的类型检查和开发工具的支持。

## 浏览器兼容方面

Vue2 的浏览器兼容性：

- 支持所有现代浏览器，包括 Chrome、Firefox、Safari、Edge 等。
- 对于较旧的浏览器，需要提供一些 polyfills 来支持 ES5 的特性，例如 Promise 和 Object.assign。

Vue3 的浏览器兼容性：

- 支持大部分现代浏览器，包括 Chrome、Firefox、Safari、Edge 等。
- 对于不支持 Proxy 的浏览器（如 IE11），需要提供额外的 polyfills 以支持 Vue3 的响应式系统。

## Vue2 基于 Object.defineProperty 有什么优缺点

**优点**：

- 支持兼容性：Object.defineProperty 是 ES5 引入的标准方法，可以在大多数现代浏览器中使用，提供了较好的兼容性。
- 精确的依赖追踪：通过 Object.defineProperty，Vue2 能够精确追踪数据的变化以及相关依赖关系。当响应式数据发生改变时，Vue 能够自动更新相关的视图，保证视图与数据的同步。
- 控制属性访问：使用 Object.defineProperty，Vue 能够控制属性的读取和设置操作。通过 getter 和 setter 函数，Vue 能够对属性进行拦截和处理，实现诸如依赖收集、派发更新等内部逻辑。

**缺点**：

- 无法监听新增属性和删除属性：Object.defineProperty 只能监听已经存在的属性的变化，对于新增的属性和删除的属性无法进行监听。这是因为 Object.defineProperty 只能在对象初始化时定义属性，后续新增或删除的属性是无法被追踪的。
- 需要遍历对象属性：为了实现响应式，Vue 需要遍历对象的每个属性并调用 Object.defineProperty 进行定义。对于大型的对象或数组，这个过程可能会比较耗时，影响性能。
- 对象嵌套层级有限制：Vue2 中的响应式系统对嵌套层级有一定的限制。当对象嵌套层级过深时，需要在每一层级上手动定义属性，比较繁琐。
- 无法监听数组索引变化：Vue2 的响应式系统对于数组的变化无法精确追踪到索引的变化。虽然 Vue 对数组方法进行了重写以实现一些特殊处理，但对于直接修改数组索引的操作，Vue 无法做出响应。

总体而言，Vue2 基于 Object.defineProperty 的响应式系统在提供兼容性和精确依赖追踪方面表现良好，但对新增属性、删除属性、数组索引等方面存在一些限制，同时在性能和嵌套层级较深的情况下可能会有一定的影响。

### Vue2 针对 Object.defineProperty 缺点提出的解决方法

- 无法监听新增或删除的属性：

Vue2 解决方法：Vue2 通过在组件实例创建时遍历数据对象，将数据对象的属性转化为响应式属性。这意味着只有在组件实例创建时已经存在的属性才会被转化为响应式属性，新增的属性无法被自动监听。

- 对象深层属性的监听困难：

Vue2 解决方法：Vue2 通过递归遍历对象的每个属性，将每个属性都转化为响应式属性，从而实现对深层对象属性的监听。这样，当深层对象属性发生变化时，也会触发相应的更新。

- 对数组的监听限制：

Vue2 解决方法：Vue2 通过重写数组的一些变异方法（如 push、pop、splice 等），来实现对数组的变动进行监听。通过这种方式，Vue2 能够捕捉到数组的变化并触发响应式更新。

值得注意的是，Vue2 在处理响应式数据时仍然使用了 Object.defineProperty，但通过上述方式来解决 Object.defineProperty 的一些限制。这些处理方法使得 Vue2 能够在很大程度上实现对象和数组的响应式更新，提供了便捷的开发体验。

然而，这些处理方式也带来了一些潜在的问题。例如，对于新增的属性，需要使用 Vue.set 方法来使其成为响应式属性；对于数组，只有通过特定的变异方法才能触发响应式更新。这些细微的限制和注意事项需要在 Vue2 开发中加以注意和处理。

## Vue3 的缺点

1. 兼容性：Vue3 对一些较旧的浏览器（如 IE11）的兼容性较差。由于 Vue3 使用了 Proxy 作为其响应式系统的基础，而 Proxy 在较旧的浏览器中不受支持，需要额外的 polyfills 才能使 Vue3 在这些浏览器上运行。
2. 生态系统的转换：由于 Vue3 的一些重大变化，许多 Vue2 的插件、组件和工具可能需要进行相应的升级才能与 Vue3 兼容。这可能需要一些时间和工作，尤其是对于一些较复杂的项目或依赖的第三方库来说。
3. 学习曲线：虽然 Vue3 的 API 在许多方面都更加简化和一致，但对于初学者来说，Vue3 相对于 Vue2 仍然具有一定的学习曲线。尤其是对于那些已经熟悉 Vue2 的开发者来说，需要花时间适应 Vue3 的新的组织方式和一些变化的概念。
4. 迁移成本：对于已经使用 Vue2 的项目来说，迁移到 Vue3 可能需要一定的工作量和时间。需要进行代码的重构和调整，以适应 Vue3 的新的语法和特性。这对于大型项目或存在复杂逻辑的项目来说可能具有挑战性。

### Vue3 中 Proxy 的优缺点

Vue3 中使用 Proxy 代替了 Vue2 中的 Object.defineProperty 来实现响应式数据。与 Object.defineProperty 相比，Proxy 具有以下优点和缺点：

**优点**：

1. 功能更强大：Proxy 相比 Object.defineProperty 提供了更丰富和灵活的拦截器（handler）功能，可以覆盖对象的各种操作，包括属性读取、属性设置、属性删除等，更方便地实现自定义逻辑。
2. 深层属性监听：Proxy 可以在访问对象的深层属性时实时捕捉到属性的读取操作，从而实现对整个对象的深层属性的监听，无需递归遍历对象的属性。
3. 数组的监听：Proxy 可以精确捕捉到数组变异方法的调用，例如 push、pop、splice 等，无需重写数组的变异方法，从而实现对数组的监听。
4. 性能优化：Proxy 相对于 Object.defineProperty，在数据监听和更新方面具有更好的性能。Proxy 在属性读取和设置时，不会像 Object.defineProperty 那样影响整个对象的所有属性，因此能够提供更高的性能。

**缺点**：

1. 兼容性：Proxy 是 ES6 的新特性，不被所有的旧版本浏览器完全支持，特别是一些较旧的移动设备浏览器和 IE 浏览器。为了在不支持 Proxy 的环境中使用 Vue3，需要额外引入 Proxy 的 polyfill。
2. 学习曲线：相对于 Vue2 的 Object.defineProperty，Proxy 在语法和使用上有一定的学习曲线，开发者需要适应新的 API 和用法，以及理解拦截器的工作原理。

## 语法上的变化

1. 组件的引入方式：

   - Vue2：使用 Vue.component 或 Vue.extend 全局注册组件，或在组件选项中使用 components 字段局部注册组件。
   - Vue3：使用 defineComponent 函数定义组件，并使用 app.component 全局注册组件，或在组件选项中使用 components 字段局部注册组件。

2. Composition API：

   - Vue2：主要通过选项式 API 编写组件，逻辑关注点按照选项的方式组织在一起。
   - Vue3：引入了 Composition API，通过 setup 函数编写组件，可以更灵活地组织和重用逻辑代码，提供了更好的可读性和维护性。

3. 响应式数据的引入方式：

   - Vue2：使用 data 选项定义组件的响应式数据，可以通过 this 来访问和修改响应式数据。
   - Vue3：使用 ref、reactive 等 API 定义组件的响应式数据。通过 value 属性来访问和修改 ref 对象的值，或使用 toRefs 将 reactive 对象转换为以 ref 包装的对象。

4. 模板中的指令和事件处理：

   - Vue2：使用 v-if、v-for 等指令来控制渲染逻辑，使用@click、@input 等修饰符来处理事件。
   - Vue3：指令改为使用 v-if、v-for 等属性的方式来表示，事件处理改为使用@click、@input 等普通属性的方式。

5. Slot（插槽）的语法：

   - Vue2：使用具名插槽和作用域插槽的语法进行插槽内容的传递和分发。
   - Vue3：引入了`<template>`标签作为默认插槽，使用`<slot>`标签定义插槽的位置，通过 v-slot 指令来具体分发插槽内容。

6. 生命周期钩子：

   - Vue2：使用一系列生命周期钩子函数（如 created、mounted、updated 等）来控制组件的生命周期。
   - Vue3：引入了新的生命周期钩子函数，包括 onBeforeMount、onMounted、onUpdated 等，更加明确和一致。

7. 静态属性：

   - Vue2：通过在组件选项中定义 static 属性来表示组件的静态属性。
   - Vue3：使用新的 defineExpose 函数来指定组件的公开属性，通过 expose 选项将其暴露给父组件。

8. 非响应式属性：

   - Vue2：所有组件选项中的属性都会进行响应式处理，如果需要定义非响应式的属性，需要使用 data 函数来返回一个非响应式对象。
   - Vue3：组件选项中的属性默认为非响应式的，不再需要使用 data 函数来定义非响应式属性。

9. Teleport（传送门）：

   - Vue2：没有内置的传送门功能，需要通过手动挂载和卸载组件来实现类似的效果。
   - Vue3：引入了新的`<teleport>`组件，用于将组件的内容传送到指定的 DOM 节点中，简化了传送门的使用。

10. 自定义指令：

    - Vue2：使用 Vue.directive 全局注册自定义指令，并在模板中使用 v-directive 指令来应用自定义指令。
    - Vue3：使用 app.directive 全局注册自定义指令，并在模板中使用 v-directive 指令来应用自定义指令，不再支持简化的指令缩写（如:directive）。

11. 过渡与动画：

    - Vue2：通过`<transition>`和`<transition-group>`组件来实现过渡和动画效果。
    - Vue3：引入了新的`<transition>`和`<teleport>`组件，并对过渡和动画的用法进行了一些改进和调整，提供了更多的选项和灵活性。

12. 异步组件：

    - Vue2：使用 Vue.component 或 import 函数来定义异步组件，并在模板中使用`<component>`标签来渲染异步组件。
    - Vue3：使用 defineAsyncComponent 函数来定义异步组件，并在模板中使用`<Suspense>`和`<template v-slot>`来处理异步组件的加载和错误状态。

13. 更好的 Tree-shaking 支持：
    - Vue2：由于 Vue2 的内部结构，无法实现很好的 Tree-shaking，导致在打包时包含了不必要的代码。
    - Vue3：通过对内部结构的改进，Vue3 能够更好地支持 Tree-shaking，减少了打包后的文件大小。
