# 箭头函数

## 箭头函数与普通函数的区别

1. 函数体内的 this 是固定的，this 绑定的是定义时所在的对象，而不是执行时所在的对象；
2. 不可以当作构造函数，即不能使用 new 操作符调用，因为它没有自己的 this，所以也不能用 call()、apply()、bind()这些方法去改变 this 的指向；
3. 不可以使用 arguments 对象，该对象在函数体不存在。可以用 rest 参数代替；
4. super、new.target 也是不存在的，分别指向外层函数的对应变量；
5. 不可以使用 yield 命令，所以不能用作 Generator 函数。
6. 箭头函数都是匿名函数表达式——它们没有用于递归或者事件绑定/解绑定的命名引用。

## 箭头函数设计的主要目的

主要设计目的是以特定的方式改变 this 的行为特性，解决 this 相关编码的一个特殊而又常见的痛点。

## 箭头函数的使用场景

1. 如果是一个简短单句在线函数表达式，其中唯一的语句是 return 某个计算出的值，且这个函数内部没有 this 引用，且没有自身引用（递归、事件绑定/解绑定），且不会要求函数执行这些，那么可以安全地把它重构为箭头函数；
2. 如果有一个内层函数表达式，依赖于在包含它的函数中调用 `var self = this` hack 或者 .bind(this) 来确保适当的 this 绑定，那么这个内层函数表达式应该可以安全地转换为箭头函数。
3. 如果你的内层函数表达式依赖于封装函数中某种像 `var args = Array.prototype.slice.call(arguments)` 来保证 arguments 的词法复制，那么这个内层函数应该可以 安全地转化为夹头函数。
4. 所有的其他情况 —— 函数声明、较长的多语句函数表达式、需要词法名称标识符（递归等）的函数，以及任何不符合以上几点特征的函数，一般都应该避免 => 函数语法。
