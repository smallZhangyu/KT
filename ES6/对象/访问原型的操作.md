# 访问原型的操作

[TOC]

## 访问原型的几种操作

### prototype

用于获取对象的原型。prototype 是一个对象。

```js
console.log(typeof Boolean.prototype); // object

console.log(Object.prototype.toString.call(Boolean.prototype)); // [object Boolean]
```

null 和 undefined 没有原型。

### \_\_proto\_\_

构造函数的原型，null 和 undefined 以外的对象均有\_\_proto\_\_。

\_\_proto\_\_是原型上的属性，而不是实例对象的自身属性。

函数和 class 的实例都有 prototype 和\_\_proto\_\_属性。

函数祖上第三代\_\_proto\_\_是 null，普通对象祖上第二代\_\_proto\_\_是 null。

```js
// 函数祖上第三代为null
function a() {}
console.log(a.__proto__.__proto__.__proto__); // null

// class 本质上也是函数，所以祖上第三代也为null
class Person {}
var stu = new Person();
console.log(stu.__proto__.__proto__.__proto__); // null

// 普通对象祖上第二代为null
console.log({ a: 23 }.__proto__.__proto__); // null
```

### instanceof

构造函数的 prototype 属性(右边的操作数)是否出现在某个实例对象(左边的操作数)的原型链上。

{} instanceof Object

### getPrototypeOf

获取对象的原型。

Object.getPrototypeOf(obj);
Reflect.getPrototypeOf(obj);

null 和 undefined 没有原型，使用该方法会报错。

### setPrototype

设置对象的原型。

Object.setPrototypeOf(obj, xxx);
Reflect.setPrototypeOf();

### isPrototypeOf

对象是否存在于另一个对象的原型链上。

Object.prototype.isPrototypeOf(obj);  
没有 prototype 这一步运算，所以左边的操作数必须是 prototype

### Object.create()

使用现有的对象来提供新创建的对象的\_\_proto\_\_

```js

```
