# 对象的属性

[TOC]

## 对象属性的分类

对象的属性 key 可以用字符串，也可以用数字表示。可分为常规属性和排序属性。

### 遍历属性的方法

1. `for(let key in obj){}`，可获取普通属性、原型属性；
2. `Object.keys(obj)`，只可获取普通属性；
3. `Object.getOwnPropertyNames(obj)`，可获取普通属性、不可枚举属性；
4. `Object.getOwnPropertySymbols(obj)`，可获取枚举属性和 Symbol 属性；
5. `Reflect.ownKeys()`，可获取普通属性、不可枚举属性、 Symbol 属性。

Reflect.ownKeys = Object.getOwnPropertyNames + getOwnPropertySymbols

### 内置属性

[[prototype]] 该内置属性在每个对象中都默认存在(Object.create(null)创建的除外)。  
所有普通的[[prototype]]链最终都指向内置的 `Object.prototype` 对象。

```js
// Object.prototype 包含许多通用的功能
constructor : ƒ Object()
hasOwnProperty : ƒ hasOwnProperty()
isPrototypeOf : ƒ isPrototypeOf()
propertyIsEnumerable : ƒ propertyIsEnumerable()
toLocaleString : ƒ toLocaleString()
toString : ƒ toString()
valueOf : ƒ valueOf()

__defineGetter__ : ƒ __defineGetter__()
__defineSetter__ : ƒ __defineSetter__()
__lookupGetter__ : ƒ __lookupGetter__()
__lookupSetter__ : ƒ __lookupSetter__()
__proto__ : null

get __proto__ : ƒ __proto__()
set __proto__ : ƒ __proto__()
```

### 常规属性

指键值为字符串的属性。特点是根据创建时的顺序排序。

### 排序属性

指键值为数字的属性。特点是按照数字索引值大小升序排列，且比常规属性的优先级高。

注意：字符串数字也是排序属性。

### 为什么设计常规属性和排序属性

1. 提升属性的访问速度；
2. 两种线性数据结构保存；

对象下有 elements 和 properties 两个地方保存属性值，elements 保存排序属性，properties 保存常规属性， 访问属性时，先从 elements 中查找，找不到才从 properties 中查找。因此排序属性优先输出。

```js
let obj = {};

obj.key2 = 'val2';
obj.key6 = 'val6';
obj.key1 = 'val1';

obj[3] = 'num3';
obj[5] = 'num5';
obj[2] = 'num2';

console.log(`obj.key ===> ` + Object.keys(obj)); // obj.key ===> 2,3,5,key2,key6,key1

for (const key in obj) {
  console.log(obj[key]); //num2 num3 num5 val2 val6 val1
}
```

### 针对排序属性和普通属性进行 赋值清空 VS delete 属性，哪个快？

10 万个对象，25 个普通属性，赋值比 delete 快十几倍。
10 万个对象，25 个排序属性，赋值比 delete 快 1~2 倍，二者相差不大。

## 对象内属性

是指被保存到对象自身的**常规**属性。  
访问时不需要经过先 elements 再到 properties 的过程查找，直接从对象下查找。  
内属性的数量有限制，一般是 10 个，超出保存到 properties 中，少量的以线性结构存储，数量多的话以非线性结构存储。

线性结构存储的属性为快属性，查找时性能快，增加、删除操作时慢；  
非线性结构存储的属性为慢属性，查找慢，增删操作快。

排序属性一般是以线性结构存储，但是也会变，比如给只有 10 个的属性，赋值 1000 下标的操作， 同时又删除修改某个下标的属性，此时存储结构有可能就变为非线性了。

## 隐藏类

对象下有个 map 的隐藏类，动态的增加删除属性会导致 map 的变化，从而影响相关性能。

### 守护隐藏类

- 初始化时保持属性顺序一致
- 一次性初始化完毕
- 谨慎使用 delete

## 对象属性的来源

1. 静态属性，`Object.assign`
2. 原型属性，`Object.prototype.toString`
3. 实例属性，`function Person(name){this.name = name}` name 为实例属性

## 操作对象属性的方法

### 对象属性的添加

1. 添加指定属性：`Object.defineProperty(obj, 'name', {value: 'haha'})`;
2. 批量添加属性：`Object.defineProperties()`;

   ```js
   Object.defineProperties(obj, {
     property1: {
       value: 42,
       writable: true,
       enumerable: true,
     },
     property2: {
       value: 'Hello',
       writable: false,
       enumerable: false,
     },
   });

   // 定义高级属性
   const obj = {};

   Object.defineProperties(obj, {
     fullName: {
       get() {
         return `${this.firstName} ${this.lastName}`;
       },
       set(value) {
         const [firstName, lastName] = value.split(' ');
         this.firstName = firstName;
         this.lastName = lastName;
       },
     },
   });

   obj.fullName = 'John Doe';
   console.log(obj.firstName); // John
   console.log(obj.lastName); // Doe
   console.log(obj.fullName); // John Doe
   ```

3. 获取指定属性的描述信息：`Object.getOwnPropertyDescriptor(obj, 'name')`；
4. 获取全部属性的描述信息：`Object.getOwnPropertyDescriptors(obj)`;

   ```js
   const obj = {};
   Object.defineProperty(obj, 'name', { value: 'peter' });

   console.log(`obj name is : ${obj.name}`);

   console.log(
     `name description: `,
     Object.getOwnPropertyDescriptor(obj, 'name')
   );

   obj.age = 34;
   console.log('obj description', Object.getOwnPropertyDescriptors(obj));
   ```

#### Object.defineProperty()的缺点

1. 无法监听数组的变化；（vue2 采用的是 defineProperty 思路，但可以监听数组的变化，是通过监听原型的某些固有的方法来实现的，可以拦截部分方法，但是一些通过下标的访问，vue2 也是拦截不到的）
2. 只能拦截对象的属性，如果对象的属性的值还是一个对象的时候，就会进行递归。

#### 属性的描述符

1. configurable：是否可配置，为 false 的话，该属性不可被删除，且不可通过`Object.defineProperty()`去重新修改（例外 writable 可由 true 改为 false，但是不可从 false 改为 true）；
2. enumerable：是否可枚举，为 false 的话，通过 for in 和 Object.keys() 获取不到该属性；
3. value： 属性的值；
4. writable： 值是否可被更改，为 false 的话，value 不可被修改；
5. get： 访问器函数；
6. set： 访问器函数；

value 和 writeable 成对出现，get 和 set 成对出现，且二者之间互斥，不会同时出现。实际可分为 2 类：

数据属性：value + writable + configurable + enumerable；  
访问器属性：get + set + configuration + enumerable；

### 对象的可扩展性

1. 可扩展性的设置：`Object.preventExtensions(obj)`，阻止添加新属性，默认不修改描述符，但是可删除属性，可修改属性的值，可修改描述符；
2. 判断对象是否可扩展：`Object.isExtensible(obj)`

### 对象的封闭

1. 设置：`Object.seal(obj)`，阻止添加新属性，默认会修改属性标记为`configurable: false`，也就是不可以删除、添加属性，但可以修改属性的值，不可修改描述符，但 writable 可由 true 修改为 false；
2. 判断对象是否封闭：`Object.isSealed(obj)`

### 对象的冻结

1. 设置：`Object.freeze(obj)`，不可添加新属性，默认会修改描述符为`configurable: false, writable: false`，不能删除、添加属性，不可修改属性的值，不能修改描述符；
2. 判断对象是否被冻结：`Object.isFrozen(obj)`

> `Object.preventExtensions()`、`Object.seal()`、`Object.freeze()` 严格程度依次变强。

## 属性的设置和屏蔽

`myObject.foo = 'bar';`  
上面这个赋值操作，实际的情况会分为很多情形：

1. myObject 对象**自身存在**foo 这个属性，赋值操作是修改 foo 的值；
2. myObject 对象自身和上层的原型链都**没有**foo 属性，该赋值操作是直接给 myObject 挂在 foo 这个属性，然后赋值；
3. myObject 和原型链上**都存在**foo 属性，myObject 的 foo 属性会屏蔽原型链上的
4. myObject 没有 foo，但是原型链上存在 foo，有分为 3 中情形

   - 如果在原型链上 foo 是普通访问属性，且不是只读的，结果是直接在 myObject 中添加一个 foo，该 foo 是屏蔽属性；
   - 如果在原型链 foo 是只读的，结果是无法修改已有属性或者在 myObject 上创建屏蔽属性，这个赋值语句会被忽略，运行在严格模式，会抛出错误；
   - 如果在原型链 foo 是一个 setter，就会调用这个 setter。foo 不会被添加到 myObject，也不会重新定义 foo 这个 setter。

   如果希望第二种和第三种情况下也屏蔽 foo，那就不能使用=操作符来赋值，而是使用 Object.defineProperty(..)来向 myObject 添加 foo。
