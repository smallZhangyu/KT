# 对象的克隆

[TOC]

## 克隆的意义和使用场景

意义： 保证元数据的完整性和独立性

常见场景：复制数据，函数入参，class 构造函数等

## 对象的多种克隆方式以及注意事项

### 浅克隆(浅拷贝)

只克隆对象的第一层级，  
如果属性值是原始数据类型，拷贝其值，也就是常说的值拷贝；  
如果属性值是引用类型，拷贝其内存地址，也就是常说的引用拷贝。

对象常用的浅拷贝方式：

1. ES6 的扩展运算符`{...obj}`;
2. `Object.assign({}, obj)`;
3. for in 和其他的一层遍历复制；

数组常用的浅拷贝方式：

1. ES6 扩展运算符`[...array]`；
2. `array.slice(0)`；
3. `[].concat(array)`；

### 深度克隆(深拷贝)

克隆对象的每个层级；  
如果属性值是原始数据类型，拷贝其值；  
如果属性值是引用类型，递归克隆。

深克隆的方式：

1. `JSON.parse(JSON.stringify(jsonObj))`；

   该方法的局限性：1、只能复制普通键的属性，Symbol 类型的无能为力；2、循环引用对象不能复制，比如全局变量 window ；3、属性值类型为函数、Date、Regexp、Blob 等类型也不能复制。这种方式性能差，如果 json 很大的话会爆栈。

2. 消息通讯-BroadcastChannel、window.postMessage、Shared Worker、Message Channel。

   该方法的局限性：1、循环引用对象不能复制；2、函数不能复制；3、同步变异步；

   ```js
   let chId = 0;
   function clone(data) {
     chId++;
     var cname = `__clone__${chId}`;
     var ch1 = new BroadcastChannel(cname);
     var ch2 = new BroadcastChannel(cname);

     return new Promise((resolve) => {
       ch2.addEventListener('message', (ev) => resolve(ev.data), {
         once: true,
       });
       ch1.postMessage(data);
     });
   }
   ```

循环引用问题的解决方法：用 weakMap；
爆栈问题的解决方法：用循环代替递归；

### 浅克隆 VS 深克隆

浅克隆优点是性能高，缺点是数据可能不完全独立，一层属性全是值类型的浅克隆等同于深度克隆。  
深克隆优点是不影响原对象，保持数据独立性，让函数无副作用；缺点是性能差，时间和空间消耗更大。
