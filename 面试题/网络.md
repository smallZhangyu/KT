# 网络相关

## 页面从输入 url 到渲染出来经历有哪些过程？

1. DNS 解析找到服务器 ip，客户端与服务端经过 3 次握手建立 TCP 连接，客户端发送 http 请求；
2. 服务端收到 http 请求，处理，并返回；
3. 客户端接收到返回数据，处理数据，渲染出页面。

三个步骤：  
网络请求：首先 DNS 域名解析得到 IP 地址，经过三次握手建立 TCP 连接，然后浏览器发起 HTTP 请求，服务器收到请求，返回 HTML 源代码；  
解析(字符串->结构化数据的过程)：HTML 源代码解析为 DOM 树，CSS 构建 CSSOM 树，二者结合生成 RenderTree；（解析 HTML 过程中，遇到静态资源还会继续发起网络请求，静态资源如果有强缓存就不必发送）  
渲染：Render Tree 绘制到页面上，计算各个 DOM 的尺寸、定位，最后绘制到页面，遇到 JS 可能会执行。(异步 CSS、图片加载，可能会触发重新渲染)

解析过程很复杂，可以做以下优化点：

1. CSS 放在 head 中，不要异步加载 CSS，异步加载会导致成浏览器重绘；
2. JS 放在 body 最下面或者合理使用 defer async；
3. img 提前定义 width，height；

![HTML页面渲染流程图](./img/HTML%20渲染流程图.png)

## 重绘 repaint 与重排 reflow 的区别？

动态网页，随时都会进行重绘与重排。

重绘：  
元素外观改变，如颜色、背景色；  
但元素的尺寸、定位不变，不会影响其他元素的位置。

重排 reflow：  
重新计算尺寸和布局，可能会影响其他元素的位置。如元素高度增加，可能会使相邻元素位置下移等。

区别：  
重排比重绘要影响更大，消耗也更大；所以要尽量避免无意义的重排。

减少重排的方法：

1. 集中修改样式，或直接切换 css class；
2. 修改之前先设置 display:none, 脱离文档流；
3. 使用 BFC 特性，不影响其他元素位置；
4. 频繁触发的操作，使用节流和防抖；
5. 使用 createDocumentFragment 批量操作 DOM；
6. 优化动画，使用 CSS3 和 requestAnimationFrame；

BFC(Block Format Context) 块级格式化上下文  
内部的元素无论如何改动，都不会影响其他元素的位置。

触发 BFC 的条件：
根节点 html
float：left/right;
overflow: auto/scroll/hidden;
display: inline-block/table/table-row/table-cell;
display: flex/grid; 的直接子元素
position: absolute/fixed;

## Script 标签中 defer 和 async 属性的区别

二者都是异步下载 script 的，区别在于 js 的执行位置，defer 是在 HTML 解析完之后执行，async 在 script 异步获取后执行，会中断 HTML 的解析过程。

![script标签中defer和async属性的差异演示](./img/script标签中defer和async属性的差异演示.png)

## cookie 的特点

1. 存储在浏览器的一段字符串（最大长度 4kb）
2. 跨域不共享
3. 格式如 k1=v1;k2=v2;因此可以存储结构化数据
4. 每次发送 http 请求，会将请求域的 cookie 一起发送给 server
5. server 可以修改 cookie 并返回给浏览器
6. 浏览器中也可以通过 js 修改 cookie（有限制的操作，document.cookie）
