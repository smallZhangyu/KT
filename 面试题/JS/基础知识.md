# JS 基础知识

## 变量类型和计算

1. typeof 能判断哪些类型？

   1. 识别所有**值类型**(结果为 'string'、'boolean'、'number'、'symbol'、'undefined')；
   2. 识别函数(结果为 'function')；
   3. 识别是否是引用类型(结果为 'object'，`typeof null` 结果是 'object')，但不可区分是哪种引用类型（通过 instanceof 去细分）

2. 何时使用 === ？何时使用 == ？

   除了 `== null` 之外，其他都一律使用 ===

   ```js
   const obj = { x: 200 };
   if (obj.a == null) {
   }
   // == null 相当于 if (obj.a === null || obj.a === undefined) {}
   ```

   == 会尝试类型转化后进行比较，数字转为字符串，0 转为 false 等等

   if 逻辑语句判断是否是 truly 变量（!!a 之后的结果），除以下 falsly 场景以外的都是 truly 变量

   ```js
   !!0 === false;
   !!NaN === false;
   !!'' === false;
   !!null === false;
   !!undefined === false;
   !!false === false;
   ```

3. 值类型和引用类型的区别

   1. 值类型变化不会影响之前赋值的结果；

      常见的值类型有：undefined，string，number，boolean，Symbol

      ```js
      let a = 100;
      let b = a;
      a = 200;
      console.log(b); // b 结果是 100
      ```

   2. 引用类型的值变化后，会影响之前的结果，因为他们之间是存储内存地址的赋值，非值赋值。

      常见的引用类型有：对象，数组，null（特殊引用类型，指针指向为空地址），function（特殊引用类型，但不用于存储数据，所以没有拷贝、复制函数一说）

      ```js
      let a = { age: 20 };
      let b = a;
      b.age = 21;
      console.log(a.age); // a.age 结果是21
      ```

## 原型和原型链

1. ES6 中的 class 本质上是 function，`typeof Student` 结果是'function'；
2. 每个 class 都有显式原型 prototype；
3. 每个 class 的实例都有隐式原型\_\_proto\_\_；
4. 实例的\_\_proto\_\_ 指向对应 class 的 prototype；
5. class 是 ES6 语法规范，由 ECMA 委员会发布，ECMA 只规定语法规则，不规定如何实现，现有 class 实际的实现方式是由 V8 引擎的实现的，是目前的主流方式。

基于原型的执行规则

1. 实例获取属性或执行方法时，先在自身属性和方法寻找；
2. 如果找不到就自动去\_\_proto\_\_(方法存储于\_\_proto\_\_)中查找；

## 作用域和闭包

1. this 不同应用场景下，如何取值？

   > this 在各个场景中取什么值，是在调用的时候确定的，不是在定义的时候。

   ```js
   // 1. 作为普通函数，指向 window
   function fn1() {
     console.log(this);
   }
   fn1(); // this 为 window

   // 2. 使用 call apply bind，指向传的参数
   fn1.call({ x: 'abc' }); // this 为 {x:'abc'}

   const fn2 = fn1.bind({ y: 123 }); // bind 方法会返回一个新的函数去调用
   fn2(); // this 为 { y: 123 }

   // 3. 作为对象方法被调用，指向对象本身
   const obj = {
     name: 'abc',
     sayHi: function () {
       console.log(this); // this 为当前对象 obj
     },
     wait: function () {
       setTimeout(function () {
         console.log(this); // this 为 window
       });
     },
     waitAgain: function () {
       setTimeout(() => {
         console.log(this); // this 为当前对象 obj
       });
     },
   };

   // 4. 在 class 方法中调用，指向当前实例
   class Person {
     consturction(name) {
       this.name = name;
     }

     say() {
       console.log(this); // this 为 当前 class
     }
   }

   const tom = new Person('tom');
   tom.say();

   // 5. 箭头函数，取它上级作用域里边的 this 对象
   function waitAgain() {
     setTimeout(() => {
       console.log(this); // this 为 window
     });
   }
   waitAgain();
   ```

2. 实际开发中闭包的应用场景，举例说明

   闭包是作用域应用的特殊情况，有 2 种表现：1. 函数作为参数被传递；2. 函数作为返回值被返回。

   > 闭包中所有自由变量的查找，是在函数定义的地方，向上级作用域查找，不是在执行的地方。

   ```js
   // 函数作为参数被传递
   function fn(cb) {
     let a = 100;
     cb();
   }

   let a = 200;
   function callback() {
     console.log(a);
   }
   fn(callback); // 200

   // 函数作为返回值被返回
   function fn2() {
     let a = 100;
     return function () {
       console.log(a);
     };
   }
   let a = 200;
   const cb = fn2();
   cb(); // 100
   ```

   实际开发的闭包的应用，隐藏数据，只提供 API

## 异步

1. 同步和异步的区别是什么？

   JS 是单线程语言，只能同时做一件事。浏览器和 nodejs 已支持 JS 启动进程，如 Web Worker。JS 和 DOM 渲染共用一个线程，因为 JS 可修改 DOM 结构。

   同步会阻塞代码的执行，而异步不会阻塞代码的执行。

2. 前端使用异步的场景有哪些？

   1. 网络请求
   2. 定时任务

3. Promise 解决了什么问题？

   Promise 解决了 callback 地狱回调（比如依次 100 次的 ajax 请求）的问题。

4. 请描述 event loop（事件轮询/事件循环）的机制

   JS 是单线程运行的，异步要基于回调来实现，event loop 就是异步回调的实现原理。

   1. 同步代码，一行一行放在 Call Stack 执行；
   2. 遇到异步代码，先记录下，等待时机（定时，网络请求等）；
   3. 如 Call Stack 为空（即同步代码执行完），Event loop 开始执行；
   4. 时机到了，就移动到 Callback Queue；
   5. 轮询查找 Callback Queue，如有内容就从 Callback Queue 移动到 Call Stack 里执行；
   6. 然后继续轮询查找

5. 什么是宏任务和微任务，两者有什么区别

6. Promise 有哪三种状态？如何变化？

7. promise then 和 catch 的连接

   ```js
   // 第一题，result：1，3
   Promise.resolve()
     .then(() => {
       console.log(1);
     })
     .catch(() => {
       console.log(2);
     })
     .then(() => {
       console.log(3);
     });

   // 第二题，result：1，2，3
   Promise.resolve()
     .then(() => {
       console.log(1);
       throw new Error('error1');
     })
     .catch(() => {
       console.log(2);
     })
     .then(() => {
       console.log(3);
     });

   // 第三题，result：1，2
   Promise.resolve()
     .then(() => {
       console.log(1);
       throw new Error('error1');
     })
     .catch(() => {
       console.log(2);
     })
     .catch(() => {
       console.log(3);
     });
   ```

8. async/await 语法

   ```js
   async function fn() {
     return 100;
   }

   (async function () {
     const a = fn();
     console.log(`a: ${a}`); // [object Promise]
     const b = await fn();
     console.log(`b: ${b}`); // 100
   })();

   // result: start, 100, 200, reject报错（Uncaught (in promise) 300）。程序终止，end 不会输出
   (async function () {
     console.log('start');

     const a = await 100;
     console.log('a', a);

     const b = await Promise.resolve(200);
     console.log('b', b);

     const c = await Promise.reject(300);
     console.log('c', c);

     console.log('end');
   })();
   ```

9. promise 和 setTimeout 的顺序

```js
// promise 比 setTimeout 先执行，result: 100,400,300,200
console.log(100);
setTimeout(() => {
  console.log(200);
}, 0);
Promise.resolve().then(() => {
  console.log(300);
});
console.log(400);
```

10. promise、setTimeout 和 async/await 的顺序问题

```js
// result:
/**
 * result:
 * 1.script start
 * 2.async1 start
 * 3.async2
 * 4.promise1
 * 5.script end
 * 6.async1 end
 * 7.promise2
 * 8.setTimeout
 */
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

async1();

new Promise(function (resolve) {
  console.log('promise1');
  resolve();
}).then(function () {
  console.log('promise2');
});

console.log('script end');
```

## window.onload 和 DOMContentLoaded 的区别？

## JS 内存垃圾回收使用什么算法？

标记清除（原来的引用计数已废弃）

## WeakMap 和 WeakSet 有什么作用？

1. 防止内存泄露
2. WeakMap 和 WeakSet 的场景：想临时记录数据或关系

## 栈溢出是什么？JS 执行和栈溢出有什么关系？

栈溢出： 例如递归次数太多，导致 stack overflow

尾递归 - 避免递归栈溢出
